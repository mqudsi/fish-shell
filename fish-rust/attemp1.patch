diff --git a/fish-rust/Cargo.lock b/fish-rust/Cargo.lock
index 00e5004bf..a0dbb47ee 100644
--- a/fish-rust/Cargo.lock
+++ b/fish-rust/Cargo.lock
@@ -316,6 +316,26 @@ dependencies = [
  "syn 1.0.109",
 ]
 
+[[package]]
+name = "dirs"
+version = "4.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ca3aa72a6f96ea37bbc5aa912f6788242832f75369bdfdadcb0e38423f100059"
+dependencies = [
+ "dirs-sys",
+]
+
+[[package]]
+name = "dirs-sys"
+version = "0.3.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1b1d1d91c932ef41c0f2663aa8b0ca0342d444d842c06914aa0a7e352d0bada6"
+dependencies = [
+ "libc",
+ "redox_users",
+ "winapi",
+]
+
 [[package]]
 name = "either"
 version = "1.8.1"
@@ -401,17 +421,25 @@ dependencies = [
  "lru",
  "miette",
  "moveit",
+ "ncurses",
  "nix",
  "num-traits",
  "once_cell",
  "pcre2",
  "printf-compat",
  "rand",
+ "terminfo",
  "unixstring",
  "widestring",
  "widestring-suffix",
 ]
 
+[[package]]
+name = "fnv"
+version = "1.0.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
+
 [[package]]
 name = "getrandom"
 version = "0.2.9"
@@ -717,6 +745,17 @@ dependencies = [
  "cxx",
 ]
 
+[[package]]
+name = "ncurses"
+version = "5.101.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5e2c5d34d72657dc4b638a1c25d40aae81e4f1c699062f72f467237920752032"
+dependencies = [
+ "cc",
+ "libc",
+ "pkg-config",
+]
+
 [[package]]
 name = "nix"
 version = "0.25.1"
@@ -796,6 +835,44 @@ version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099"
 
+[[package]]
+name = "phf"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "928c6535de93548188ef63bb7c4036bd415cd8f36ad25af44b9789b2ee72a48c"
+dependencies = [
+ "phf_shared",
+]
+
+[[package]]
+name = "phf_codegen"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a56ac890c5e3ca598bbdeaa99964edb5b0258a583a9eb6ef4e89fc85d9224770"
+dependencies = [
+ "phf_generator",
+ "phf_shared",
+]
+
+[[package]]
+name = "phf_generator"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b1181c94580fa345f50f19d738aaa39c0ed30a600d95cb2d3e23f94266f14fbf"
+dependencies = [
+ "phf_shared",
+ "rand",
+]
+
+[[package]]
+name = "phf_shared"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e1fb5f6f826b772a8d4c0394209441e7d37cbbb967ae9c7e0e8134365c9ee676"
+dependencies = [
+ "siphasher",
+]
+
 [[package]]
 name = "pkg-config"
 version = "0.3.26"
@@ -901,6 +978,15 @@ dependencies = [
  "getrandom",
 ]
 
+[[package]]
+name = "redox_syscall"
+version = "0.2.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
+dependencies = [
+ "bitflags",
+]
+
 [[package]]
 name = "redox_syscall"
 version = "0.3.5"
@@ -910,6 +996,17 @@ dependencies = [
  "bitflags",
 ]
 
+[[package]]
+name = "redox_users"
+version = "0.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b033d837a7cf162d7993aded9304e30a83213c648b6e389db233191f891e5c2b"
+dependencies = [
+ "getrandom",
+ "redox_syscall 0.2.16",
+ "thiserror",
+]
+
 [[package]]
 name = "regex"
 version = "1.7.3"
@@ -1008,6 +1105,12 @@ version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "43b2853a4d09f215c24cc5489c992ce46052d359b5109343cbafbf26bc62f8a3"
 
+[[package]]
+name = "siphasher"
+version = "0.3.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7bd3e3206899af3f8b12af284fafc038cc1dc2b41d1b89dd17297221c5d225de"
+
 [[package]]
 name = "smawk"
 version = "0.3.1"
@@ -1085,7 +1188,7 @@ checksum = "b9fbec84f381d5795b08656e4912bec604d162bff9291d6189a78f4c8ab87998"
 dependencies = [
  "cfg-if",
  "fastrand",
- "redox_syscall",
+ "redox_syscall 0.3.5",
  "rustix",
  "windows-sys 0.45.0",
 ]
@@ -1109,6 +1212,19 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "terminfo"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "666cd3a6681775d22b200409aad3b089c5b99fb11ecdd8a204d9d62f8148498f"
+dependencies = [
+ "dirs",
+ "fnv",
+ "nom",
+ "phf",
+ "phf_codegen",
+]
+
 [[package]]
 name = "textwrap"
 version = "0.15.2"
diff --git a/fish-rust/Cargo.toml b/fish-rust/Cargo.toml
index 849282d17..0c2f77474 100644
--- a/fish-rust/Cargo.toml
+++ b/fish-rust/Cargo.toml
@@ -20,10 +20,12 @@ lazy_static = "1.4.0"
 libc = "0.2.137"
 lru = "0.10.0"
 moveit = "0.5.1"
+ncurses = "5.101.0"
 nix = { version = "0.25.0", default-features = false, features = [] }
 num-traits = "0.2.15"
 once_cell = "1.17.0"
 rand = { version = "0.8.5", features = ["small_rng"] }
+terminfo = "0.8.0"
 unixstring = "0.2.7"
 widestring = "1.0.2"
 
diff --git a/fish-rust/src/common.rs b/fish-rust/src/common.rs
index cb154f08b..bc7424870 100644
--- a/fish-rust/src/common.rs
+++ b/fish-rust/src/common.rs
@@ -1344,7 +1344,7 @@ pub type FilenameRef = Rc<WString>;
 /// This function should be called after calling `setlocale()` to perform fish specific locale
 /// initialization.
 #[widestrs]
-fn fish_setlocale() {
+pub fn fish_setlocale() {
     // Use various Unicode symbols if they can be encoded using the current locale, else a simple
     // ASCII char alternative. All of the can_be_encoded() invocations should return the same
     // true/false value since the code points are in the BMP but we're going to be paranoid. This
diff --git a/fish-rust/src/env/environment.rs b/fish-rust/src/env/environment.rs
index 0a0b30697..9a4b14dfd 100644
--- a/fish-rust/src/env/environment.rs
+++ b/fish-rust/src/env/environment.rs
@@ -34,8 +34,12 @@ lazy_static! {
 static UVARS_LOCALLY_MODIFIED: RelaxedAtomicBool = RelaxedAtomicBool::new(false);
 
 /// Convert an EnvVar to an FFI env_var_t.
-fn env_var_to_ffi(var: EnvVar) -> cxx::UniquePtr<ffi::env_var_t> {
-    ffi::env_var_t::new_ffi(Box::into_raw(Box::from(var)).cast()).within_unique_ptr()
+pub fn env_var_to_ffi(var: Option<EnvVar>) -> cxx::UniquePtr<ffi::env_var_t> {
+    if let Some(var) = var {
+        ffi::env_var_t::new_ffi(Box::into_raw(Box::from(var)).cast()).within_unique_ptr()
+    } else {
+        cxx::UniquePtr::null()
+    }
 }
 
 /// An environment is read-only access to variable values.
@@ -60,7 +64,7 @@ pub trait Environment {
         };
         let mut pwd = WString::new();
         if var.is_empty() {
-            pwd = var.as_string();
+            pwd = var.as_string().into_owned();
         }
         if !pwd.ends_with('/') {
             pwd.push('/');
diff --git a/fish-rust/src/env/environment_impl.rs b/fish-rust/src/env/environment_impl.rs
index 525b554dd..345976aad 100644
--- a/fish-rust/src/env/environment_impl.rs
+++ b/fish-rust/src/env/environment_impl.rs
@@ -16,6 +16,7 @@ use crate::wutil::{fish_wcstoi_opts, sprintf, Options};
 use autocxx::WithinUniquePtr;
 use cxx::UniquePtr;
 use lazy_static::lazy_static;
+use std::borrow::Cow;
 use std::cell::{RefCell, UnsafeCell};
 use std::collections::HashSet;
 use std::ffi::CString;
@@ -387,10 +388,8 @@ impl EnvScopedImpl {
                 .getf(L!("fish_history"), EnvMode::DEFAULT)
                 .map(|v| v.as_string());
             let history_session_id = fish_history_var
-                .as_ref()
-                .map(WString::as_utfstr)
-                .unwrap_or(DFLT_FISH_HISTORY_SESSION_ID);
-            let vals = get_history_var_text(history_session_id);
+                .unwrap_or(Cow::Borrowed(DFLT_FISH_HISTORY_SESSION_ID));
+            let vals = get_history_var_text(&history_session_id);
             return Some(EnvVar::new_from_name_vec("history"L, vals));
         } else if key == "fish_killring"L {
             Some(EnvVar::new_from_name_vec(
diff --git a/fish-rust/src/env/mod.rs b/fish-rust/src/env/mod.rs
index f6787bff4..140bc44ef 100644
--- a/fish-rust/src/env/mod.rs
+++ b/fish-rust/src/env/mod.rs
@@ -5,4 +5,44 @@ pub mod var;
 
 pub use env_ffi::EnvStackSetResult;
 pub use environment::*;
+use std::ffi::CString;
 pub use var::*;
+use std::sync::atomic::{AtomicUsize, AtomicBool};
+
+extern "C" {
+    static read_byte_limit: AtomicUsize;
+    static curses_initialized: AtomicBool;
+    static term_has_xn: AtomicBool;
+}
+
+// TODO: Once the env.h/env.cpp port is complete, change the types to be the atomics named above and
+// expose them as `pub static` values directly instead of this rigamole.
+pub static READ_BYTE_LIMIT: &AtomicUsize = unsafe { std::mem::transmute(&read_byte_limit) };
+pub static CURSES_INITIALIZED: &AtomicBool = unsafe { std::mem::transmute(&curses_initialized) };
+pub static TERM_HAS_XN: &AtomicBool = unsafe { std::mem::transmute(&term_has_xn) };
+
+mod ffi {
+    extern "C" {
+        pub fn setenv_lock(
+            name: *const libc::c_char,
+            value: *const libc::c_char,
+            overwrite: libc::c_int,
+        );
+        pub fn unsetenv_lock(name: *const libc::c_char);
+    }
+}
+
+pub fn setenv_lock(name: &str, value: &str, overwrite: bool) {
+    unsafe {
+        let name = CString::new(name).unwrap();
+        let value = CString::new(value).unwrap();
+        self::ffi::setenv_lock(name.as_ptr(), value.as_ptr(), libc::c_int::from(overwrite));
+    }
+}
+
+pub fn unsetenv_lock(name: &str) {
+    unsafe {
+        let name = CString::new(name).unwrap();
+        self::ffi::unsetenv_lock(name.as_ptr());
+    }
+}
diff --git a/fish-rust/src/env/var.rs b/fish-rust/src/env/var.rs
index e5bc96c14..ab2c94aab 100644
--- a/fish-rust/src/env/var.rs
+++ b/fish-rust/src/env/var.rs
@@ -4,6 +4,7 @@ use crate::wcstringutil::join_strings;
 use bitflags::bitflags;
 use lazy_static::lazy_static;
 use libc::c_int;
+use std::borrow::Cow;
 use std::collections::HashMap;
 use std::sync::Arc;
 
@@ -199,8 +200,14 @@ impl EnvVar {
     }
 
     /// Returns the variable's value as a string.
-    pub fn as_string(&self) -> WString {
-        join_strings(&self.values, self.get_delimiter())
+    pub fn as_string<'a>(&'a self) -> Cow<'a, widestring::Utf32Str> {
+        if self.values.len() == 0 {
+            Cow::Owned(WString::new())
+        } else if self.values.len() == 1 {
+            Cow::Borrowed(&self.values[0])
+        } else {
+            Cow::Owned(join_strings(&self.values, self.get_delimiter()))
+        }
     }
 
     /// Copies the variable's values into an existing list, avoiding reallocation if possible.
diff --git a/fish-rust/src/fallback.rs b/fish-rust/src/fallback.rs
index d429d0c2b..80a203af0 100644
--- a/fish-rust/src/fallback.rs
+++ b/fish-rust/src/fallback.rs
@@ -10,21 +10,26 @@ use std::cmp;
 use std::sync::atomic::{AtomicI32, Ordering};
 use std::{ffi::CString, mem, os::fd::RawFd};
 
-// Width of ambiguous characters. 1 is typical default.
-static FISH_AMBIGUOUS_WIDTH: AtomicI32 = AtomicI32::new(1);
+/// Width of ambiguous characters. 1 is typical default.
+pub static FISH_AMBIGUOUS_WIDTH: AtomicI32 = AtomicI32::new(1);
 
-// Width of emoji characters.
-// 1 is the typical emoji width in Unicode 8.
-static FISH_EMOJI_WIDTH: AtomicI32 = AtomicI32::new(1);
+/// Width of emoji characters.
+///
+/// 1 is the typical emoji width in Unicode 8.
+// For some reason, this is declared here and exposed here, but is set in `env_dispatch`.
+pub static FISH_EMOJI_WIDTH: AtomicI32 = AtomicI32::new(1);
 
+/// Width of emoji characters.
+///
+/// 1 is the typical emoji width in Unicode 8.
 fn fish_get_emoji_width() -> i32 {
     FISH_EMOJI_WIDTH.load(Ordering::Relaxed)
 }
 
 extern "C" {
-    pub fn wcwidth(c: libc::wchar_t) -> libc::c_int;
+    fn wcwidth(c: libc::wchar_t) -> libc::c_int;
 }
-fn system_wcwidth(c: char) -> i32 {
+pub fn system_wcwidth(c: char) -> i32 {
     const _: () = assert!(mem::size_of::<libc::wchar_t>() >= mem::size_of::<char>());
     unsafe { wcwidth(c as libc::wchar_t) }
 }
diff --git a/fish-rust/src/ffi.rs b/fish-rust/src/ffi.rs
index f01f4b639..d5f3f8a26 100644
--- a/fish-rust/src/ffi.rs
+++ b/fish-rust/src/ffi.rs
@@ -20,6 +20,7 @@ pub type wchar_t = u32;
 include_cpp! {
     #include "builtin.h"
     #include "common.h"
+    #include "complete.h"
     #include "env.h"
     #include "env_dispatch.h"
     #include "env_universal_common.h"
@@ -30,7 +31,9 @@ include_cpp! {
     #include "flog.h"
     #include "function.h"
     #include "highlight.h"
+    #include "history.h"
     #include "io.h"
+    #include "input_common.h"
     #include "kill.h"
     #include "parse_constants.h"
     #include "parser.h"
@@ -38,6 +41,7 @@ include_cpp! {
     #include "path.h"
     #include "proc.h"
     #include "reader.h"
+    #include "screen.h"
     #include "tokenizer.h"
     #include "wildcard.h"
     #include "wutil.h"
@@ -133,6 +137,19 @@ include_cpp! {
     generate!("kill_entries_ffi")
 
     generate!("get_history_variable_text_ffi")
+
+    generate!("is_interactive_session")
+    generate!("set_interactive_session")
+    generate!("screen_set_midnight_commander_hack")
+    generate!("screen_clear_layout_cache_ffi")
+    generate!("reader_schedule_prompt_repaint")
+    generate!("reader_change_history")
+    generate!("history_session_id")
+    generate!("reader_change_cursor_selection_mode")
+    generate!("reader_set_autosuggestion_enabled_ffi")
+    generate!("function_invalidate_path")
+    generate!("complete_invalidate_path")
+    generate!("update_wait_on_escape_ms_ffi")
 }
 
 impl parser_t {
diff --git a/fish-rust/src/flog.rs b/fish-rust/src/flog.rs
index 9add0b6cd..56232c786 100644
--- a/fish-rust/src/flog.rs
+++ b/fish-rust/src/flog.rs
@@ -150,7 +150,7 @@ pub trait FloggableDisplay {
 
 impl<T: std::fmt::Display> FloggableDisplay for T {
     fn to_flog_str(&self) -> String {
-        format!("{}", self)
+        self.to_string()
     }
 }
 
diff --git a/fish-rust/src/lib.rs b/fish-rust/src/lib.rs
index 74a68d00a..776bf418e 100644
--- a/fish-rust/src/lib.rs
+++ b/fish-rust/src/lib.rs
@@ -19,6 +19,7 @@ mod builtins;
 mod color;
 mod compat;
 mod env;
+mod env_dispatch;
 mod event;
 mod expand;
 mod fallback;
@@ -44,12 +45,14 @@ mod locale;
 mod nix;
 mod null_terminated_array;
 mod operation_context;
+mod output;
 mod parse_constants;
 mod parse_tree;
 mod parse_util;
 mod parser_keywords;
 mod path;
 mod re;
+mod reader;
 mod redirection;
 mod signal;
 mod smoke;
diff --git a/fish-rust/src/path.rs b/fish-rust/src/path.rs
index b7e3c541d..9e387340a 100644
--- a/fish-rust/src/path.rs
+++ b/fish-rust/src/path.rs
@@ -590,11 +590,11 @@ fn make_base_directory(xdg_var: &wstr, non_xdg_homepath: &wstr) -> BaseDirectory
     let mut path = WString::new();
     let used_xdg;
     if let Some(xdg_dir) = vars.getf_unless_empty(xdg_var, EnvMode::GLOBAL | EnvMode::EXPORT) {
-        path = xdg_dir.as_string() + "/fish"L;
+        path = xdg_dir.as_string().into_owned() + "/fish"L;
         used_xdg = true;
     } else {
         if let Some(home) = vars.getf_unless_empty("HOME"L, EnvMode::GLOBAL | EnvMode::EXPORT) {
-            path = home.as_string() + non_xdg_homepath;
+            path = home.as_string().into_owned() + non_xdg_homepath;
         }
         used_xdg = false;
     }
diff --git a/fish-rust/src/termsize.rs b/fish-rust/src/termsize.rs
index 089d62f6c..517b2a28c 100644
--- a/fish-rust/src/termsize.rs
+++ b/fish-rust/src/termsize.rs
@@ -1,6 +1,6 @@
 // Support for exposing the terminal size.
 use crate::common::assert_sync;
-use crate::env::EnvMode;
+use crate::env::{EnvMode, Environment};
 use crate::ffi::{environment_t, parser_t, Repin};
 use crate::flog::FLOG;
 use crate::wchar::{WString, L};
@@ -226,21 +226,42 @@ impl TermsizeContainer {
     }
 
     /// Note that COLUMNS and/or LINES global variables changed.
-    fn handle_columns_lines_var_change(&self, vars: &environment_t) {
+    fn handle_columns_lines_var_change(&self, vars: &dyn Environment) {
         // Do nothing if we are the ones setting it.
         if self.setting_env_vars.load(Ordering::Relaxed) {
             return;
         }
         // Construct a new termsize from COLUMNS and LINES, then set it in our data.
         let new_termsize = Termsize {
-            width: var_to_int_or(
-                vars.get_as_string_flags(L!("COLUMNS"), EnvMode::GLOBAL),
-                Termsize::DEFAULT_WIDTH,
-            ),
-            height: var_to_int_or(
-                vars.get_as_string_flags(L!("LINES"), EnvMode::GLOBAL),
-                Termsize::DEFAULT_HEIGHT,
-            ),
+            width: vars.getf(L!("COLUMNS"), EnvMode::GLOBAL)
+                .map(|v| v.as_string())
+                .and_then(|v| fish_wcstoi(v.chars()).ok())
+                .unwrap_or(Termsize::DEFAULT_WIDTH),
+            height: vars.getf(L!("LINES"), EnvMode::GLOBAL)
+                .map(|v| v.as_string())
+                .and_then(|v| fish_wcstoi(v.chars()).ok())
+                .unwrap_or(Termsize::DEFAULT_HEIGHT),
+        };
+
+        // Store our termsize as an environment override.
+        self.data
+            .lock()
+            .unwrap()
+            .mark_override_from_env(new_termsize);
+    }
+
+    /// Note that COLUMNS and/or LINES global variables changed.
+    fn handle_columns_lines_var_change_ffi(&self, vars: &environment_t) {
+        // Do nothing if we are the ones setting it.
+        if self.setting_env_vars.load(Ordering::Relaxed) {
+            return;
+        }
+        // Construct a new termsize from COLUMNS and LINES, then set it in our data.
+        let new_termsize = Termsize {
+            width: var_to_int_or(vars.get_as_string_flags(L!("COLUMNS"), EnvMode::GLOBAL),
+            Termsize::DEFAULT_WIDTH),
+            height: var_to_int_or(vars.get_as_string_flags(L!("LINES"), EnvMode::GLOBAL),
+            Termsize::DEFAULT_HEIGHT),
         };
 
         // Store our termsize as an environment override.
@@ -280,13 +301,16 @@ pub fn termsize_last() -> Termsize {
 }
 
 /// Called when the COLUMNS or LINES variables are changed.
-/// The pointer is to an environment_t, but has the wrong type to satisfy cxx.
-pub fn handle_columns_lines_var_change_ffi(vars_ptr: *const u8) {
-    assert!(!vars_ptr.is_null());
-    let vars: &environment_t = unsafe { &*(vars_ptr as *const environment_t) };
+pub fn handle_columns_lines_var_change(vars: &dyn Environment) {
     SHARED_CONTAINER.handle_columns_lines_var_change(vars);
 }
 
+fn handle_columns_lines_var_change_ffi(vars_ptr: *const u8) {
+    assert!(!vars_ptr.is_null());
+    let vars: &environment_t = unsafe { &*(vars_ptr.cast()) };
+    SHARED_CONTAINER.handle_columns_lines_var_change_ffi(vars);
+}
+
 /// Called to initialize the termsize.
 /// The pointer is to an environment_t, but has the wrong type to satisfy cxx.
 pub fn termsize_initialize_ffi(vars_ptr: *const u8) -> Termsize {
@@ -351,13 +375,13 @@ add_test!("test_termsize", || {
     // Now the tty's termsize doesn't matter.
     parser.set_var(L!("COLUMNS"), &[L!("75")], env_global);
     parser.set_var(L!("LINES"), &[L!("150")], env_global);
-    ts.handle_columns_lines_var_change(parser.get_var_stack_env());
+    ts.handle_columns_lines_var_change_ffi(parser.get_var_stack_env());
     assert_eq!(ts.last(), Termsize::new(75, 150));
     assert_eq!(parser.var_as_string(L!("COLUMNS")).unwrap(), "75");
     assert_eq!(parser.var_as_string(L!("LINES")).unwrap(), "150");
 
     parser.set_var(L!("COLUMNS"), &[L!("33")], env_global);
-    ts.handle_columns_lines_var_change(parser.get_var_stack_env());
+    ts.handle_columns_lines_var_change_ffi(parser.get_var_stack_env());
     assert_eq!(ts.last(), Termsize::new(33, 150));
 
     // Oh it got SIGWINCH, now the tty matters again.
diff --git a/fish-rust/src/wchar_ext.rs b/fish-rust/src/wchar_ext.rs
index c6715f10a..6f0ad439b 100644
--- a/fish-rust/src/wchar_ext.rs
+++ b/fish-rust/src/wchar_ext.rs
@@ -226,6 +226,15 @@ pub trait WExt {
         }
     }
 
+    /// Returns the index of the first match against the provided substring or `None`.
+    fn find(&self, search: impl AsRef<[char]>) -> Option<usize> {
+        fn inner(lhs: &[char], rhs: &[char]) -> Option<usize> {
+            lhs.windows(rhs.len()).position(|window| window == lhs)
+        }
+
+        inner(self.as_char_slice(), search.as_ref())
+    }
+
     /// \return the index of the first occurrence of the given char, or None.
     fn find_char(&self, c: char) -> Option<usize> {
         self.as_char_slice().iter().position(|&x| x == c)
diff --git a/src/env.cpp b/src/env.cpp
index 9e868cb7f..9fb3d253f 100644
--- a/src/env.cpp
+++ b/src/env.cpp
@@ -50,10 +50,12 @@
 /// At init, we read all the environment variables from this array.
 extern char **environ;
 
+extern "C" {
 bool curses_initialized = false;
 
 /// Does the terminal have the "eat_newline_glitch".
 bool term_has_xn = false;
+}
 
 // static
 env_var_t env_var_t::new_ffi(EnvVar *ptr) {
diff --git a/src/env.h b/src/env.h
index 8b0dc4410..ae46acb17 100644
--- a/src/env.h
+++ b/src/env.h
@@ -43,8 +43,8 @@ struct event_list_ffi_t {
 
 struct owning_null_terminated_array_t;
 
-extern size_t read_byte_limit;
-extern bool curses_initialized;
+extern "C" size_t read_byte_limit;
+extern "C" bool curses_initialized;
 
 // Flags that may be passed as the 'mode' in env_stack_t::set() / environment_t::get().
 enum : uint16_t {
diff --git a/src/history.cpp b/src/history.cpp
index 7a0af2aa7..1725f3b17 100644
--- a/src/history.cpp
+++ b/src/history.cpp
@@ -1273,10 +1273,10 @@ void history_impl_t::incorporate_external_changes() {
 }
 
 /// Return the prefix for the files to be used for command and read history.
-wcstring history_session_id(const environment_t &vars) {
+wcstring history_session_id(std::unique_ptr<env_var_t> fish_history) {
     wcstring result = DFLT_FISH_HISTORY_SESSION_ID;
 
-    const auto var = vars.get(L"fish_history");
+    const auto var = std::move(fish_history);
     if (var) {
         wcstring session_id = var->as_string();
         if (session_id.empty()) {
@@ -1294,6 +1294,13 @@ wcstring history_session_id(const environment_t &vars) {
     return result;
 }
 
+wcstring history_session_id(const environment_t &vars) {
+    auto fish_history = vars.get(L"fish_history");
+    auto var = fish_history ? std::make_unique<env_var_t>(*fish_history) :
+        std::unique_ptr<env_var_t> {};
+    return history_session_id(std::move(var));
+}
+
 path_list_t expand_and_detect_paths(const path_list_t &paths, const environment_t &vars) {
     ASSERT_IS_BACKGROUND_THREAD();
     std::vector<wcstring> result;
diff --git a/src/history.h b/src/history.h
index fff284321..1d6d49d54 100644
--- a/src/history.h
+++ b/src/history.h
@@ -316,8 +316,14 @@ class history_search_t {
 /** Saves the new history to disk. */
 void history_save_all();
 
+#if INCLUDE_RUST_HEADERS
 /** Return the prefix for the files to be used for command and read history. */
 wcstring history_session_id(const environment_t &vars);
+#endif
+
+/** FFI version of above **/
+class env_var_t;
+wcstring history_session_id(std::unique_ptr<env_var_t> fish_history);
 
 /**
     Given a list of proposed paths and a context, perform variable and home directory expansion,
diff --git a/src/input_common.cpp b/src/input_common.cpp
index e827b3d70..1f9b4db2d 100644
--- a/src/input_common.cpp
+++ b/src/input_common.cpp
@@ -140,6 +140,23 @@ void update_wait_on_escape_ms(const environment_t& vars) {
     }
 }
 
+void update_wait_on_escape_ms_ffi(std::unique_ptr<env_var_t> fish_escape_delay_ms) {
+    if (!fish_escape_delay_ms) {
+        wait_on_escape_ms = WAIT_ON_ESCAPE_DEFAULT;
+        return;
+    }
+
+    long tmp = fish_wcstol(fish_escape_delay_ms->as_string().c_str());
+    if (errno || tmp < 10 || tmp >= 5000) {
+        std::fwprintf(stderr,
+                      L"ignoring fish_escape_delay_ms: value '%ls' "
+                      L"is not an integer or is < 10 or >= 5000 ms\n",
+                      fish_escape_delay_ms->as_string().c_str());
+    } else {
+        wait_on_escape_ms = static_cast<int>(tmp);
+    }
+}
+
 maybe_t<char_event_t> input_event_queue_t::try_pop() {
     if (queue_.empty()) {
         return none();
diff --git a/src/input_common.h b/src/input_common.h
index a53c46b5d..976eb1d16 100644
--- a/src/input_common.h
+++ b/src/input_common.h
@@ -186,6 +186,7 @@ class char_event_t {
 /// Adjust the escape timeout.
 class environment_t;
 void update_wait_on_escape_ms(const environment_t &vars);
+void update_wait_on_escape_ms_ffi(std::unique_ptr<env_var_t> fish_escape_delay_ms);
 
 /// A class which knows how to produce a stream of input events.
 /// This is a base class; you may subclass it for its override points.
diff --git a/src/output.cpp b/src/output.cpp
index da0ff8f99..bc494c2e6 100644
--- a/src/output.cpp
+++ b/src/output.cpp
@@ -41,9 +41,10 @@ static bool term_supports_color_natively(unsigned int c) {
     return static_cast<unsigned>(max_colors) >= c + 1;
 }
 
-color_support_t output_get_color_support() { return color_support; }
-
-void output_set_color_support(color_support_t val) { color_support = val; }
+extern "C" {
+    void output_set_color_support(color_support_t val) { color_support = val; }
+    color_support_t output_get_color_support() { return color_support; }
+}
 
 unsigned char index_for_color(rgb_color_t c) {
     if (c.is_named() || !(output_get_color_support() & color_support_term256)) {
diff --git a/src/output.h b/src/output.h
index 2b786c31c..4aee22e6e 100644
--- a/src/output.h
+++ b/src/output.h
@@ -127,8 +127,10 @@ rgb_color_t parse_color(const env_var_t &var, bool is_background);
 /// Sets what colors are supported.
 enum { color_support_term256 = 1 << 0, color_support_term24bit = 1 << 1 };
 using color_support_t = unsigned int;
-color_support_t output_get_color_support();
-void output_set_color_support(color_support_t val);
+extern "C" {
+    color_support_t output_get_color_support();
+    void output_set_color_support(color_support_t val);
+}
 
 rgb_color_t best_color(const std::vector<rgb_color_t> &candidates, color_support_t support);
 
diff --git a/src/reader.cpp b/src/reader.cpp
index 0e25a45f6..436acff89 100644
--- a/src/reader.cpp
+++ b/src/reader.cpp
@@ -2922,6 +2922,10 @@ void reader_change_cursor_selection_mode(cursor_selection_mode_t selection_mode)
     }
 }
 
+void reader_change_cursor_selection_mode(uint8_t selection_mode) {
+    reader_change_cursor_selection_mode((cursor_selection_mode_t) selection_mode);
+}
+
 static bool check_autosuggestion_enabled(const env_stack_t &vars) {
     if (auto val = vars.get(L"fish_autosuggestion_enabled")) {
         return val->as_string() != L"0";
@@ -2942,6 +2946,18 @@ void reader_set_autosuggestion_enabled(const env_stack_t &vars) {
     }
 }
 
+void reader_set_autosuggestion_enabled_ffi(bool enable) {
+    // We don't need to _change_ if we're not initialized yet.
+    reader_data_t *data = current_data_or_null();
+    if (data) {
+        if (data->conf.autosuggest_ok != enable) {
+            data->conf.autosuggest_ok = enable;
+            data->force_exec_prompt_and_repaint = true;
+            data->inputter.queue_char(readline_cmd_t::repaint);
+        }
+    }
+}
+
 /// Add a new reader to the reader stack.
 /// \return a shared pointer to it.
 static std::shared_ptr<reader_data_t> reader_push_ret(parser_t &parser,
diff --git a/src/reader.h b/src/reader.h
index 4d282be28..8d4cf9524 100644
--- a/src/reader.h
+++ b/src/reader.h
@@ -168,11 +168,16 @@ enum class cursor_selection_mode_t : uint8_t {
     inclusive,
 };
 
+#if INCLUDE_RUST_HEADERS
 void reader_change_cursor_selection_mode(cursor_selection_mode_t selection_mode);
+#endif
+void reader_change_cursor_selection_mode(uint8_t selection_mode);
 
 /// Enable or disable autosuggestions based on the associated variable.
 void reader_set_autosuggestion_enabled(const env_stack_t &vars);
 
+void reader_set_autosuggestion_enabled_ffi(bool);
+
 /// Write the title to the titlebar. This function is called just before a new application starts
 /// executing and just after it finishes.
 ///
diff --git a/src/screen.cpp b/src/screen.cpp
index 3b47df9ab..e76b3bb4b 100644
--- a/src/screen.cpp
+++ b/src/screen.cpp
@@ -63,6 +63,10 @@ class scoped_buffer_t : noncopyable_t, nonmovable_t {
 // Note this is deliberately exported so that init_curses can clear it.
 layout_cache_t layout_cache_t::shared;
 
+void screen_clear_layout_cache_ffi() {
+    layout_cache_t::shared.clear();
+}
+
 /// Tests if the specified narrow character sequence is present at the specified position of the
 /// specified wide character string. All of \c seq must match, but str may be longer than seq.
 static size_t try_sequence(const char *seq, const wchar_t *str) {
diff --git a/src/screen.h b/src/screen.h
index 4c667baa6..d215fa4da 100644
--- a/src/screen.h
+++ b/src/screen.h
@@ -244,6 +244,8 @@ class screen_t {
 /// Issues an immediate clr_eos.
 void screen_force_clear_to_end();
 
+void screen_clear_layout_cache_ffi();
+
 // Information about the layout of a prompt.
 struct prompt_layout_t {
     std::vector<size_t> line_breaks;  // line breaks when rendering the prompt
